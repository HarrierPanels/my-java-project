pipeline {
    agent {
        label 'local1'
    }

    environment {
        // AWS credentials
        AWS_CREDS = credentials('aws-creds')
    }

    stages {

        stage('Checkout') {
            steps {
                // Checkout your source code from your version control system
                checkout scm
            }
        }

        stage('Fetch Docker Hub Tags') {
            steps {
                script {
                    // Define Docker Hub variables
                    def repository = 'harrierpanels/myapp'
                    def url = "https://hub.docker.com/v2/repositories/${repository}/tags"
                    def response = sh(script: "curl -s ${url}", returnStdout: true)

                    if (response) {
                        def tags = new groovy.json.JsonSlurper().parseText(response).results.name
                        env.VERSION = input message: 'Select Version', parameters: [choice(choices: tags, description: 'Choose a version', name: 'VERSION')]
                    } else {
                        error("Failed to fetch Docker Hub tags")
                    }
                }
            }
        }

        stage('Select Environment') {
            steps {
                script {
                    env.ENVIRONMENT = input message: 'Select Environment', parameters: [choice(choices: 'dev\nqa', description: 'Choose an environment', name: 'ENVIRONMENT')]
                }
            }
        }
        stage('Deploy to Environment') {
            when {
                expression { env.ENVIRONMENT == 'dev' || env.ENVIRONMENT == 'qa' }
            }
            steps {
                script {
                    if (env.ENVIRONMENT == 'dev') {
                        echo "${env.VERSION} chosen for ${env.ENVIRONMENT}:"
                        sh "sed -i 's/harrierpanels\\/myapp:latest/harrierpanels\\/myapp:${env.VERSION}/g' dev-deployment-service.yaml"
                        sh "kubectl apply -f dev-deployment-service.yaml"

                        // Wait for the LoadBalancer to be assigned an external IP
                        echo "Waiting for the LoadBalancer to be assigned an external IP..."
                        def lbExternalIp = ''
                        timeout(time: 15, unit: 'MINUTES') {
                            // Wait for the LoadBalancer to have an external IP
                            def lbStatus = ''
                            while (lbStatus != 'active' || lbExternalIp.isEmpty()) {
                                lbStatus = sh(script: "aws elbv2 describe-load-balancers --names myapp-service -q 'LoadBalancers[0].State.Code' --output text", returnStatus: true, returnStdout: true).trim()
                                if (lbStatus == 'active') {
                                    lbExternalIp = sh(script: "aws elbv2 describe-load-balancers --names myapp-service --query 'LoadBalancers[0].DNSName' --output text", returnStatus: true, returnStdout: true).trim()
                                } else {
                                    sleep 30  // Sleep for 30 seconds and then check again
                                }
                            }
                        }
                        if (!lbExternalIp.isEmpty()) {
                            env.PUB_IP = lbExternalIp
                        } else {
                            error "Failed to retrieve public IP address"
                        }
                    } else if (env.ENVIRONMENT == 'qa') {
                        echo "${env.VERSION} chosen for ${env.ENVIRONMENT}:"
                        sh "sed -i 's/harrierpanels\\/myapp:latest/harrierpanels\\/myapp:${env.VERSION}/g' qa-deployment-service.json"
                        sh "cat qa-deployment-service.json"
                        } else {
                            error "Failed to retrieve public IP address"
                        }
                    }
            }
        }
        stage('Send Notifications') {
            steps {
                script {
                    def message = "Deployment of myapp:${env.VERSION} to ${env.ENVIRONMENT} environment is complete"
                    echo "${message}"
                }
            }
        }
    }
}
